<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
	<title>Die Verhinderung der Windenergie</title>

	<script src="maplibre-gl.js"></script>
	<link href="maplibre-gl.css" rel="stylesheet" />
	<style>
		html {
			height: -webkit-fill-available;
			overflow: hidden;
			overflow-x: hidden;
			overflow-y: hidden;
		}

		body {
			width: 100vw;
			min-height: 100vh;
			min-height: -webkit-fill-available;
			margin: 0;
			padding: 0;
			overflow: hidden;
			overflow-x: hidden;
			overflow-y: hidden;
			position: relative;
		}

		#map {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
		}

		.maplibregl-ctrl-attrib-inner {
			line-height: 1.2em;
		}

		.maplibregl-ctrl-attrib {
			box-shadow: 0 0 5px #000;
		}

		.maplibregl-ctrl-bottom-left {
			width: 100%;
			height: 80px;
			background-color: #fff;
			position: absolute;
			bottom: 0px;
			pointer-events: all;
		}

		.maplibregl-ctrl-bottom-right {
			bottom: 80px;
		}

		.search-container input {
			border-radius: 5px;
			padding: 2px 3px;
			border: 1px solid #888;
		}

		.slider-container {
			width: 100%;
			padding: 0px;
			height: 80px;
			box-sizing: border-box;
			position: relative;
			user-select: none;
		}

		.slider-container * {
			position: absolute;
			pointer-events: none;
		}

		.slider-track {
			top: 30px;
			height: 3px;
			border-radius: 2px;
			background-color: #000;
			z-index: 100;
		}

		.slider-thumb {
			top: 2px;
			width: 50px;
			height: 35px;
			margin-left: -25px;
			cursor: pointer;
		}

		.slider-sign {
			top: 0px;
			left: 0px;
			width: 50px;
			height: 22px;
			background: #d50d2e;
			border-radius: 10px;
			color: #fff;
			font-size: 12px;
			text-align: center;
		}

		.slider-mark {
			top: 22px;
			left: 19px;
			width: 0px;
			height: 0px;
			background: transparent;
			border: 6px solid transparent;
			border-top: 6px solid #d50d2e;
		}

		.slider-label {
			top: 30px;
			font-size: 10px;
			opacity: 0.5;
			border-left: 1px solid #000;
			border-right: 1px solid #000;
			line-height: 1em;
			padding: 0 2px;
		}
	</style>
</head>

<body>
	<div id="map"></div>
	<script>
		(() => {
			const maxDistance = 2500;
			const minDistance = 0;
			const distance = 1000;
			let container = document.getElementById("map");
			let map = new maplibregl.Map({
				container,
				//style: "https://cdn.michael-kreil.de/map/style/positron/white.json",
				style: "https://static.datenhub.net/maps/styles/positron/white.json",
				bounds: [5.86, 47.27, 15.04, 55.05],
				fitBoundsOptions: { padding: { top: 5, bottom: 85, left: 5, right: 5 } },
				maxBounds: [0.8, 43.7, 20.1, 57.1],
				maxZoom: 13,
				minPitch: 0,
				maxPitch: 0,
				hash: true,
				dragRotate: false,
				touchPitch: false,
				attributionControl: false,
			});
			map.touchZoomRotate.disableRotation();

			let attributionControl = new maplibregl.AttributionControl({
				compact: true,
				customAttribution: [
					"Kartenhintergrund",
					[
						"OpenStreetMap Mitwirkende;https://www.openstreetmap.org/copyright",
					],
					"Naturschutzgebiete etc.",
					[
						"Bundesamt für Naturschutz;https://geodienste.bfn.de/schutzgebiete?lang=de&layers=LSG",
					],
					"Infrastruktur und Gebäudeumrisse",
					[
						"Landesamt für Geoinformation und Landentwicklung Baden-Württemberg;https://www.lgl-bw.de/Produkte/Liegenschaftskataster/Hausumringe/",
						"Landesamt für Digitalisierung, Breitband und Vermessung Bayern;https://www.ldbv.bayern.de/produkte/kataster/hausumringe.html",
						"Senatsverwaltung für Stadtentwicklung, Bauen und Wohnen Berlin;https://daten.berlin.de/datensaetze/alkis-berlin-geb%C3%A4ude-wfs",
						"Landesvermessung und Geobasisinformation Brandenburg;https://geobasis-bb.de/lgb/de/geodaten/liegenschaftskataster/hausumringe/",
						"Landesamt Geoinformation Bremen;https://www.geo.bremen.de/produkte/katasterprodukte/hausumringe-und-hauskoordinaten-12289",
						"Landesbetrieb Geoinformation und Vermessung Hamburg;https://suche.transparenz.hamburg.de/dataset/inspire-hh-gebaeude-alkis?forceWeb=true",
						"Hessische Verwaltung für Bodenmanagement und Geoinformation;https://gds.hessen.de/INTERSHOP/web/WFS/HLBG-Geodaten-Site/de_DE/-/EUR/ViewDownloadcenter-Start",
						"Landesamt für Geoinformation, Vermessung und Katasterwesen Mecklenburg-Vorpommern;https://www.geoportal-mv.de/portal/Suche/Metadatenuebersicht/Details/Hausumringe%20(HU)%20-%20Land%20Mecklenburg-Vorpommern/e665bc47-44f4-4194-b5ee-1784a628ea3b",
						"Landesamt für Geoinformation und Landesvermessung Niedersachsen;https://www.lgln.niedersachsen.de/startseite/geodaten_karten/liegenschaftsinformationen_aus_alkis/hauskoordinaten_hausumringe/hauskoordinaten-und-hausumringe-90177.html",
						"Geobasis NRW;https://open.nrw/dataset/3f08a580-48ec-43c1-936d-d62f89c21cc9",
						"Landesamt für Vermessung und Geobasisinformation Rheinland-Pfalz;https://lvermgeo.rlp.de/de/produkte/liegenschaftskataster/hauskoordinaten-hausumringe/",
						"Landesamt für Vermessung, Geoinformation und Landentwicklung Saarland;https://www.shop.lvgl.saarland.de/index.php?option=com_virtuemart&view=category&virtuemart_category_id=1087&virtuemart_manufacturer_id=0&Itemid=191",
						"Staatsbetrieb Geobasisinformation und Vermessung Sachsen;https://www.geodaten.sachsen.de/downloadbereich-hausumringe-4174.html",
						"Landesamt für Vermessung und Geoinformation Sachsen-Anhalt;https://www.lvermgeo.sachsen-anhalt.de/de/kostenfreie_geobasisdaten_lvermgeo.html",
						"Landesamt für Vermessung und Geoinformation Schleswig-Holstein;https://www.schleswig-holstein.de/DE/landesregierung/ministerien-behoerden/LVERMGEOSH/Service/serviceGeobasisdaten/geodatenService_Geobasisdaten_sonstigeDaten.html",
						"Thüringer Landesamt für Bodenmanagement und Geoinformation;https://www.geoportal-th.de/de-de/Downloadbereiche/Download-Offene-Geodaten-Th%C3%BCringen",
					],
					"Daten zu bestehenden Windrädern",
					[
						"Bundesnetzagentur;https://www.marktstammdatenregister.de/MaStR/Datendownload",
					]
				]
					.map(e => {
						if (typeof e === 'string') return `<b>${e}:</b>`;
						return e.map(l => {
							l = l.split(";");
							return l[1]
								? `<a href="${l[1]}" target="_blank">© ${l[0]}</a>`
								: `${l[0]}`;
						}).join(', ') + '<br>'
					})
					.join(" "),
			});
			map.addControl(attributionControl);
			attributionControl._updateCompactMinimize();

			map.addControl(new SearchControl(), "top-right");

			map.addControl(new maplibregl.FullscreenControl());

			map.addControl(
				new maplibregl.NavigationControl({ showCompass: false }),
				"top-left"
			);

			const sdfLimit = (distance - minDistance) / (maxDistance - minDistance);
			const sdfWidth = 1 / (maxDistance - minDistance);

			map.on("load", async () => {
				//map.getStyle().layers.forEach(l => map.removeLayer(l.id))
				map.addSource("tilesSource", {
					type: "raster",
					tiles: [
						"https://cdn.michael-kreil.de/data/windradabstand/{z}/{y}/{x}.webp",
					],
					bounds: [5.8, 47.2, 15.1, 55.1],
					minzoom: 0,
					maxzoom: 13,
					tileSize: 256,
				});
				map.addLayer({
					id: "tilesLayer",
					type: "raster",
					source: "tilesSource",
					paint: {
						"raster-sdf-limit": sdfLimit,
						"raster-sdf-width": sdfWidth,
						"raster-opacity": 1.0,
					},
				});

				map.addControl(new SliderControl({
					minValue: 400,
					maxValue: 2000,
					handle: (v) => {
						//console.log(v);
						v = (v - minDistance) / (maxDistance - minDistance);
						if (v < 0) v = 0;
						if (v > 1) v = 1;
						map.setPaintProperty("tilesLayer", "raster-sdf-limit", v);
						map.triggerRepaint();
					},
				}), "bottom-left");
			});

			function loadViaAjax(url) {
				return new Promise((res, rej) => {
					let req = new XMLHttpRequest();
					req.open("GET", url, true);
					req.onload = () => {
						if (req.status < 200 || req.status >= 400) {
							console.log(req);
							return rej(req.status);
						}
						res(req.response);
					};
					req.send();
				});
			}

			function SliderControl(opt) {
				const labels = [
					{ value: 400, y: 2, short: "HH, NI, ST, SH", long: "Hamburg, Niedersachsen, Sachsen-Anhalt, Schleswig-Holstein" },
					{ value: 450, y: 1, short: "HB", long: "Bremen" },
					{ value: 500, y: 0, short: "RLP", long: "Rheinland Pfalz" },
					{ value: 600, y: 1, short: "TH", long: "Thüringen" },
					{ value: 650, y: 0, short: "SL", long: "Saarland" },
					{ value: 700, y: 1, short: "BW", long: "Baden-Württemberg" },
					{ value: 800, y: 0, short: "MV", long: "Mecklenburg-Vorpommern" },
					{ value: 1000, y: 0, short: "BB, HE, NRW, SN", long: "Brandenburg, Hessen, NRW, Sachsen" },
					{ value: 2000, y: 0, short: "Bayern", long: "Bayern", right: true },
				];
				let value = 1000;
				let map;
				return { onAdd };
				function onAdd(_map) {
					map = _map;

					const paddingHori = 20;

					const container = createDomNode("div", { className: "slider-container" });

					const track = createDomNode("div", { className: "slider-track" }, container);
					const thumb = createDomNode("div", { className: "slider-thumb" }, container);
					const sign = createDomNode("div", { className: "slider-sign" }, thumb);
					const mark = createDomNode("div", { className: "slider-mark" }, thumb);

					track.style.left = paddingHori + "px";
					track.style.right = paddingHori + "px";

					labels.forEach((label) => {
						label.node = createDomNode(
							"div",
							{ className: "slider-label" },
							container
						);
						label.node.innerText = label.short;
						label.pos =
							(label.value - opt.minValue) / (opt.maxValue - opt.minValue);

						if (label.right) {
							label.node.style.borderLeft = "none";
						} else {
							label.node.style.borderRight = "none";
						}
						label.node.style.paddingTop = 5 + label.y * 13 + "px";
					});

					let trackWidth,
						pointerX;

					updateSize();
					opt.handle(value);
					setTimeout(updateSize, 0);
					setTimeout(updateSize, 100);
					window.addEventListener("resize", updateSize);

					function updateSize() {
						trackWidth = container.offsetWidth - 2 * paddingHori;
						labels.forEach((label) => {
							let x = Math.round(trackWidth * label.pos);
							if (label.right) {
								label.node.style.right = paddingHori + trackWidth - x + "px";
							} else {
								label.node.style.left = paddingHori + x + "px";
							}
						});
						updatePosition();
					}

					function updatePosition() {
						let x = Math.round(
							(trackWidth * (value - opt.minValue)) /
							(opt.maxValue - opt.minValue)
						);
						thumb.style.left = x + paddingHori + "px";
						track.style.background = 'linear-gradient(to right, #d50d2e, #d50d2e '+x+'px, #000 '+x+'px)';
						sign.innerText = value + "m";

						labels.forEach((label) => {
							let d = 1 - (label.value - value) / 50;
							if (d < 0) d = 0;
							label.node.style.opacity = d * 0.7 + 0.3;
						});
					}

					container.addEventListener('pointerdown', e => {
						dragTo(e.pageX);
					});
					container.addEventListener('pointermove', e => {
						//console.log('pointermove', e.buttons);
						if (e.buttons > 0) dragTo(e.pageX);
					});
					container.addEventListener('touchmove', e => {
						//console.log('touchmove', e);
						if (e.touches[0]) dragTo(e.touches[0].pageX);
					});

					function dragTo(x) {
						let v = (x - paddingHori) / trackWidth;
						if (v < 0) v = 0;
						if (v > 1) v = 1;
						v = opt.minValue + v * (opt.maxValue - opt.minValue);
						v = Math.round(v / 50) * 50;

						if (v === value) return;
						value = v;
						updatePosition();
						opt.handle(v);
					}

					return container;
				}
			}

			function SearchControl(opt) {
				return { onAdd };
				function onAdd(_map) {
					map = _map;

					const paddingHori = 0;

					const container = createDomNode("div", { className: "search-container maplibregl-ctrl maplibregl-ctrl-group" });

					const input = createDomNode("input", { type: 'text', placeholder: 'Suche nach: Ort/PLZ/Adresse', size: 30 }, container);

					return container;
				}
			}

			function createDomNode(tagName, attr, parent) {
				let node = document.createElement(tagName);
				if (attr) Object.assign(node, attr);
				if (parent) parent.append(node);
				return node;
			}
		})();
	</script>
</body>

</html>